{
  "openapi": "3.1.0",
  "info": {
    "title": "Mini Chat API",
    "version": "1.0.0",
    "description": "Multi-tenant AI chat module. Provides conversational AI with streaming responses, document and image upload, file search, per-user quota enforcement, and audit event emission. All endpoints require authentication and tenant license verification (ai_chat feature)."
  },
  "jsonSchemaDialect": "https://json-schema.org/draft/2020-12/schema",
  "servers": [],
  "security": [
    {
      "bearerAuth": []
    }
  ],
  "tags": [
    {
      "name": "chats",
      "description": "Chat lifecycle: create, list, get, delete."
    },
    {
      "name": "messages",
      "description": "Send messages and receive streamed AI responses (SSE)."
    },
    {
      "name": "attachments",
      "description": "Upload documents and images to a chat."
    },
    {
      "name": "turns",
      "description": "Turn status query and tail-only mutations (retry, edit, delete)."
    },
    {
      "name": "reactions",
      "description": "Binary like/dislike reactions on assistant messages."
    }
  ],
  "paths": {
    "/v1/chats": {
      "post": {
        "operationId": "createChat",
        "tags": ["chats"],
        "summary": "Create a new chat",
        "description": "Creates a chat for the authenticated user. The optional `model` field selects a model from the deployment model catalog; if omitted, the default model is resolved: the is_default premium model, or the first enabled premium model, or the first enabled standard model. The model is locked for the chat lifetime.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChatRequest"
              },
              "example": {
                "title": "Q3 Financial Analysis",
                "model": "gpt-5.2"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Chat created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Chat"
                },
                "example": {
                  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                  "model": "gpt-5.2",
                  "title": "Q3 Financial Analysis",
                  "is_temporary": false,
                  "created_at": "2025-06-15T10:30:00Z",
                  "updated_at": "2025-06-15T10:30:00Z"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (e.g. unknown model name).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          }
        }
      },
      "get": {
        "operationId": "listChats",
        "tags": ["chats"],
        "summary": "List chats for the current user",
        "description": "Returns chats for the authenticated user ordered by most recent activity (updated_at DESC). Supports cursor-based pagination and OData `$select` field projection. This endpoint supports OData `$select` for sparse field projection. Field names are case-insensitive. Dot notation is supported for nested objects.",
        "parameters": [
          {
            "$ref": "#/components/parameters/PaginationCursor"
          },
          {
            "$ref": "#/components/parameters/PaginationLimit"
          },
          {
            "$ref": "#/components/parameters/ODataSelect"
          }
        ],
        "responses": {
          "200": {
            "description": "Paginated list of chat objects.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["items", "page_info"],
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Chat"
                      }
                    },
                    "page_info": {
                      "$ref": "#/components/schemas/PageInfo"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          }
        }
      }
    },
    "/v1/chats/{id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        }
      ],
      "get": {
        "operationId": "getChat",
        "tags": ["chats"],
        "summary": "Get chat metadata",
        "description": "Returns chat metadata (including selected model) and message_count. Does NOT embed messages; use `GET /v1/chats/{id}/messages` to load conversation history with cursor pagination.",
        "responses": {
          "200": {
            "description": "Chat metadata with message count.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatDetail"
                },
                "example": {
                  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                  "model": "gpt-5.2",
                  "title": "Q3 Financial Analysis",
                  "is_temporary": false,
                  "message_count": 12,
                  "created_at": "2025-06-15T10:30:00Z",
                  "updated_at": "2025-06-15T10:36:30Z"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          }
        }
      },
      "delete": {
        "operationId": "deleteChat",
        "tags": ["chats"],
        "summary": "Delete a chat",
        "description": "Soft-deletes the chat and marks attachments for asynchronous cleanup. External provider resources (files, chat vector stores) are removed by a background cleanup worker with idempotent retries.",
        "responses": {
          "204": {
            "description": "Chat deleted. Cleanup of external resources is asynchronous."
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          }
        }
      }
    },
    "/v1/chats/{id}/messages:stream": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        }
      ],
      "post": {
        "operationId": "sendMessage",
        "tags": ["messages"],
        "summary": "Send message and receive streamed AI response",
        "description": "Sends a user message and opens an SSE stream for the assistant response. If `request_id` matches an active generation, returns 409 Conflict (JSON, no SSE). If `request_id` matches a completed generation, replays the response as SSE (side-effect-free: no new quota reserve, no billing events).\n\nThe optional `web_search` parameter enables web search for this turn (disabled by default, backward compatible).\n\n**SSE event ordering (P1)**: `ping* delta* tool* citations? (done | error)`. `delta` and `tool` may interleave; at most one `citations` event, emitted after all `delta` events and before the terminal event.\n\nExactly one terminal event (`done` or `error`) ends the stream.\n\n**SSE event types and payloads**:\n- `event: ping` — keepalive, payload: `{}`. Clients MUST ignore.\n- `event: delta` — incremental text. Payload: `SseDeltaEvent`.\n- `event: tool` — tool activity (file_search, web_search at P1). Payload: `SseToolEvent`.\n- `event: citations` — source references (file and web). Payload: `SseCitationsEvent`.\n- `event: done` — terminal success with usage and quota_decision. Payload: `SseDoneEvent`.\n- `event: error` — terminal failure. Payload: `SseErrorEvent`.\n\nSee component schemas for payload definitions.\n\n**Pre-stream errors**: If validation, authorization, or quota preflight fails before streaming, a JSON error response with the appropriate HTTP status is returned and no SSE stream is opened.\n\n**Cancellation**: If the client disconnects mid-stream, the server cancels the in-flight provider request and applies a bounded best-effort debit for quota. No SSE error event is emitted (the stream is already broken). The Turn Status API is authoritative for final state after disconnect.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SendMessageRequest"
              },
              "example": {
                "content": "What does the document say about Q3 revenue?",
                "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                "attachment_ids": ["c3d4e5f6-7890-4abc-def1-234567890abc"],
                "web_search": { "enabled": false }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SSE stream opened. Events delivered as `text/event-stream`. HTTP 200 does NOT guarantee success — terminal failures after streaming starts are delivered as SSE `event: error` (payload: SseErrorEvent) while the HTTP status remains 200. Non-200 JSON error responses (4xx/5xx below) occur only when the failure is detected before the SSE stream is opened. See operation description for event types and payload schemas.",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "Server-Sent Events stream. Each event has `event:` type and `data:` JSON payload. See SseDeltaEvent, SseToolEvent, SseCitationsEvent, SseDoneEvent, SseErrorEvent schemas."
                }
              }
            },
            "headers": {
              "Cache-Control": {
                "schema": {
                  "type": "string",
                  "const": "no-cache"
                }
              },
              "Connection": {
                "schema": {
                  "type": "string",
                  "const": "keep-alive"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Possible codes: `too_many_images` (exceeds per-message image input limit), `web_search_disabled` (web search requested but kill switch is active).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          },
          "409": {
            "description": "Conflict: either (a) a generation is already running for this chat (one running turn per chat policy), or (b) the same `(chat_id, request_id)` is already in a non-replayable state (`running`, `failed`, or `cancelled`). Code: `generation_in_progress` or `request_id_conflict`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Image bytes exceeded per-turn limit. Code: `image_bytes_exceeded`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "Effective model does not support multimodal input. Validation occurs after downgrade decision and before provider call. Code: `unsupported_media`. Defensive: under the P1 catalog invariant (all enabled models include VISION_INPUT) this response is not expected; it activates if a future catalog introduces a non-vision model or on catalog misconfiguration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Quota or rate limit exceeded. Code: `quota_exceeded` (with `quota_scope`: `tokens` or `web_search`) for user quota exhaustion (always pre-stream), or `rate_limited` for upstream provider throttling after OAGW retry exhaustion. `rate_limited` may also appear as a terminal SSE `event: error` if the provider returns 429 mid-stream (HTTP status remains 200 in that case). Clients MUST use the `code` field to distinguish the two.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "502": {
            "description": "LLM provider error. Code: `provider_error`. Returned as JSON response if failure occurs before SSE stream is opened. If failure occurs after streaming begins, delivered as terminal SSE `event: error` while HTTP status remains 200.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "504": {
            "description": "LLM provider timeout. Code: `provider_timeout`. Returned as JSON response if failure occurs before SSE stream is opened. If failure occurs after streaming begins, delivered as terminal SSE `event: error` while HTTP status remains 200.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chats/{id}/attachments": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        }
      ],
      "post": {
        "operationId": "uploadAttachment",
        "tags": ["attachments"],
        "summary": "Upload a document or image to a chat",
        "description": "Uploads a file as an attachment. MIME type determines `kind`: `image/png`, `image/jpeg`, `image/webp` produce `image` attachments; all other supported types produce `document` attachments. Documents are indexed in the chat's dedicated vector store and optionally summarized. Images are stored via the provider Files API but NOT indexed in vector stores. Returns immediately with `status: pending`; transitions to `ready` or `failed` asynchronously.",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "required": ["file"],
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary",
                    "description": "The file to upload."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Attachment created. Processing is asynchronous; poll `GET /v1/chats/{id}/attachments/{attachment_id}` for status transitions (pending -> ready or pending -> failed). `doc_summary` is server-generated and null until background processing completes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Attachment"
                },
                "example": {
                  "attachment_id": "c3d4e5f6-7890-4abc-def1-234567890abc",
                  "status": "pending",
                  "kind": "document",
                  "filename": "Q3_Report.pdf",
                  "content_type": "application/pdf",
                  "size_bytes": 245000,
                  "doc_summary": null,
                  "img_thumbnail": null,
                  "created_at": "2025-06-15T10:35:00Z"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          },
          "413": {
            "description": "File exceeds the configured upload size limit. Code: `file_too_large`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "File type not supported. Code: `unsupported_file_type`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Daily upload quota exceeded. Code: `quota_exceeded`, `quota_scope`: `uploads`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "502": {
            "description": "Provider file upload failed. Code: `provider_error`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chats/{id}/messages": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        }
      ],
      "get": {
        "operationId": "listMessages",
        "tags": ["messages"],
        "summary": "List messages with cursor pagination",
        "description": "Returns paginated messages for a chat using cursor-based pagination with OData query support. Default ordering is `created_at asc` (chronological). Use `$orderby`, `$filter`, and `$select` for advanced queries.\n\n**OData support**:\n- `$orderby`: `created_at asc|desc`, `id asc|desc`\n- `$filter`: `created_at` (eq, ne, gt, ge, lt, le), `role` (eq, ne, in), `id` (eq, ne, in)\n- `$select`: any top-level field (including `attachment_ids`)",
        "parameters": [
          {
            "$ref": "#/components/parameters/PaginationLimit"
          },
          {
            "$ref": "#/components/parameters/PaginationCursor"
          },
          {
            "$ref": "#/components/parameters/ODataSelect"
          },
          {
            "$ref": "#/components/parameters/ODataOrderBy"
          },
          {
            "$ref": "#/components/parameters/ODataFilter"
          }
        ],
        "x-odata-orderby": {
          "supported_fields": ["created_at", "id"],
          "supported_directions": ["asc", "desc"],
          "default": "created_at asc"
        },
        "x-odata-filter": {
          "supported_fields": {
            "created_at": ["eq", "ne", "gt", "ge", "lt", "le"],
            "role": ["eq", "ne", "in"],
            "id": ["eq", "ne", "in"]
          }
        },
        "responses": {
          "200": {
            "description": "Paginated list of messages.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MessagesPage"
                },
                "example": {
                  "items": [
                    {
                      "id": "e5f6a7b8-9012-4cde-f123-456789abcdef",
                      "role": "user",
                      "content": "What does the document say about Q3 revenue?",
                      "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                      "model": null,
                      "input_tokens": null,
                      "output_tokens": null,
                      "attachment_ids": ["c3d4e5f6-7890-4abc-def1-234567890abc"],
                      "created_at": "2025-06-15T10:35:30Z"
                    },
                    {
                      "id": "d4e5f6a7-8901-4bcd-ef12-3456789abcde",
                      "role": "assistant",
                      "content": "Based on the Q3 report, revenue grew 15%...",
                      "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                      "model": "gpt-5.2",
                      "input_tokens": 500,
                      "output_tokens": 120,
                      "attachment_ids": [],
                      "created_at": "2025-06-15T10:35:45Z"
                    }
                  ],
                  "page_info": {
                    "limit": 20,
                    "next_cursor": "eyJjcmVhdGVkX2F0IjoiMjAyNS0wNi0xNVQxMDozNTo0NVoiLCJpZCI6ImQ0ZTVmNmE3In0=",
                    "prev_cursor": null
                  }
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          }
        }
      }
    },
    "/v1/chats/{id}/attachments/{attachment_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        },
        {
          "$ref": "#/components/parameters/AttachmentId"
        }
      ],
      "get": {
        "operationId": "getAttachment",
        "tags": ["attachments"],
        "summary": "Get attachment status and metadata",
        "description": "Returns the current status and metadata of an attachment. Use this endpoint to poll for processing completion after upload (status transitions: `pending` -> `ready` or `pending` -> `failed`). The `doc_summary` field is populated asynchronously by a server background task and is null until processing completes (always null for images).",
        "responses": {
          "200": {
            "description": "Attachment metadata and status.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Attachment"
                },
                "examples": {
                  "document_attachment": {
                    "summary": "Document attachment (ready, with summary)",
                    "value": {
                      "attachment_id": "c3d4e5f6-7890-4abc-def1-234567890abc",
                      "status": "ready",
                      "kind": "document",
                      "filename": "Q3_Report.pdf",
                      "content_type": "application/pdf",
                      "size_bytes": 245000,
                      "doc_summary": "Q3 financial report showing 15% revenue growth and expanded margins.",
                      "img_thumbnail": null,
                      "error_code": null,
                      "summary_updated_at": "2025-06-15T10:35:30Z",
                      "created_at": "2025-06-15T10:35:00Z"
                    }
                  },
                  "image_attachment": {
                    "summary": "Image attachment (ready, with thumbnail preview)",
                    "value": {
                      "attachment_id": "d4e5f6a7-8901-4abc-def1-234567890abd",
                      "status": "ready",
                      "kind": "image",
                      "filename": "architecture_diagram.png",
                      "content_type": "image/png",
                      "size_bytes": 1048576,
                      "doc_summary": null,
                      "img_thumbnail": {
                        "content_type": "image/webp",
                        "width": 128,
                        "height": 96,
                        "data_base64": "UklGRlYAAABXRUJQVlA4IEoAAADQAQCdASoIAAYAAkA..."
                      },
                      "error_code": null,
                      "summary_updated_at": null,
                      "created_at": "2025-06-15T10:36:00Z"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          }
        }
      }
    },
    "/v1/chats/{id}/turns/{request_id}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        },
        {
          "$ref": "#/components/parameters/RequestId"
        }
      ],
      "get": {
        "operationId": "getTurnStatus",
        "tags": ["turns"],
        "summary": "Get authoritative turn status",
        "description": "Returns the authoritative server-side turn state for a given request_id. Used by the UI for disconnect recovery. Internal states map to API states: running->running, completed->done, failed->error, cancelled->cancelled. Includes error_code (when state is 'error') and assistant_message_id (when state is 'done') so clients can resolve lifecycle uncertainty after disconnect without listing or scanning message history. Retrieving the assistant message content itself may require one follow-up request. Billing outcome and provider internals are not exposed.",
        "responses": {
          "200": {
            "description": "Turn status.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TurnStatus"
                },
                "example": {
                  "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                  "state": "done",
                  "error_code": null,
                  "assistant_message_id": "b2c3d4e5-f6a7-8901-bcde-f12345678901",
                  "updated_at": "2025-06-15T10:36:30Z"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          }
        }
      },
      "patch": {
        "operationId": "editTurn",
        "tags": ["turns"],
        "summary": "Edit the last user turn and regenerate response",
        "description": "Replaces the content of the last user message and generates a new assistant response via SSE. The previous turn is soft-deleted with `replaced_by_request_id` set. Original `attachment_ids` are preserved. Only the most recent non-deleted turn in a terminal state may be edited.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EditTurnRequest"
              },
              "example": {
                "content": "What about Q3 profit margins?"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SSE stream with new assistant response. Same event contract as sendMessage.",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "Server-Sent Events stream. See sendMessage operation for event types."
                }
              }
            }
          },
          "400": {
            "description": "Turn not in terminal state. Code: `invalid_turn_state`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          },
          "409": {
            "description": "Target is not the most recent turn. Code: `not_latest_turn`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Quota or rate limit exceeded for regeneration. Code: `quota_exceeded` (`quota_scope`: `tokens`) for user quota exhaustion (always pre-stream), or `rate_limited` for upstream provider throttling. `rate_limited` may also appear as a terminal SSE `event: error` mid-stream (HTTP 200). Same semantics as sendMessage.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Image bytes exceeded per-turn limit. Code: `image_bytes_exceeded`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "415": {
            "description": "Effective model does not support multimodal input. Code: `unsupported_media`. Same semantics as sendMessage.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "502": {
            "description": "LLM provider error. Code: `provider_error`. Same semantics as sendMessage.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "504": {
            "description": "LLM provider timeout. Code: `provider_timeout`. Same semantics as sendMessage.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "deleteTurn",
        "tags": ["turns"],
        "summary": "Delete the last turn",
        "description": "Soft-deletes the most recent turn (user message + assistant response). Only the latest non-deleted turn in a terminal state may be deleted. No replacement turn is created.",
        "responses": {
          "200": {
            "description": "Turn deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TurnDeleteResponse"
                },
                "example": {
                  "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                  "deleted": true
                }
              }
            }
          },
          "400": {
            "description": "Turn not in terminal state. Code: `invalid_turn_state`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          },
          "409": {
            "description": "Target is not the most recent turn. Code: `not_latest_turn`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chats/{id}/turns/{request_id}:retry": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        },
        {
          "$ref": "#/components/parameters/RequestId"
        }
      ],
      "post": {
        "operationId": "retryTurn",
        "tags": ["turns"],
        "summary": "Retry the last turn",
        "description": "Soft-deletes the previous turn and re-submits the original user message (including any attachment_ids) for a new assistant response via SSE. Only the most recent non-deleted turn in a terminal state may be retried.",
        "responses": {
          "200": {
            "description": "SSE stream with new assistant response. Same event contract as sendMessage.",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "Server-Sent Events stream. See sendMessage operation for event types."
                }
              }
            }
          },
          "400": {
            "description": "Turn not in terminal state. Code: `invalid_turn_state`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "$ref": "#/components/responses/NotFound"
          },
          "409": {
            "description": "Target is not the most recent turn. Code: `not_latest_turn`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Quota or rate limit exceeded for regeneration. Code: `quota_exceeded` (`quota_scope`: `tokens`) for user quota exhaustion (always pre-stream), or `rate_limited` for upstream provider throttling. `rate_limited` may also appear as a terminal SSE `event: error` mid-stream (HTTP 200). Same semantics as sendMessage.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chats/{id}/messages/{msg_id}/reaction": {
      "parameters": [
        {
          "$ref": "#/components/parameters/ChatId"
        },
        {
          "$ref": "#/components/parameters/MessageId"
        }
      ],
      "put": {
        "operationId": "setReaction",
        "tags": ["reactions"],
        "summary": "Set like/dislike on an assistant message",
        "description": "Upserts a binary reaction on an assistant message. Only assistant messages may receive reactions. Idempotent: replaces any existing reaction for this user on this message.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetReactionRequest"
              },
              "example": {
                "reaction": "like"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reaction set.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReactionResponse"
                },
                "example": {
                  "message_id": "d4e5f6a7-8901-4bcd-ef12-3456789abcde",
                  "reaction": "like",
                  "created_at": "2025-06-15T10:37:00Z"
                }
              }
            }
          },
          "400": {
            "description": "Target is not an assistant message. Code: `invalid_reaction_target`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "description": "Chat or message not found. Code: `chat_not_found` or `message_not_found`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "removeReaction",
        "tags": ["reactions"],
        "summary": "Remove reaction from an assistant message",
        "description": "Removes the current user's reaction from an assistant message. Idempotent: returns 200 even if no reaction exists.",
        "responses": {
          "200": {
            "description": "Reaction removed (or was already absent).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReactionDeleteResponse"
                }
              }
            }
          },
          "403": {
            "$ref": "#/components/responses/Forbidden"
          },
          "404": {
            "description": "Chat or message not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "Platform AuthN JWT or opaque token. Extracts user_id and tenant_id into the request security context."
      }
    },
    "parameters": {
      "ChatId": {
        "name": "id",
        "in": "path",
        "required": true,
        "description": "Chat UUID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "RequestId": {
        "name": "request_id",
        "in": "path",
        "required": true,
        "description": "Client-generated idempotency key UUID identifying a turn.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "MessageId": {
        "name": "msg_id",
        "in": "path",
        "required": true,
        "description": "Message UUID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "AttachmentId": {
        "name": "attachment_id",
        "in": "path",
        "required": true,
        "description": "Attachment UUID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "PaginationLimit": {
        "name": "limit",
        "in": "query",
        "required": false,
        "description": "Maximum number of items to return.",
        "schema": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20
        }
      },
      "PaginationCursor": {
        "name": "cursor",
        "in": "query",
        "required": false,
        "description": "Opaque cursor for fetching the next or previous page.",
        "schema": {
          "type": "string"
        }
      },
      "ODataSelect": {
        "name": "$select",
        "in": "query",
        "required": false,
        "description": "OData v4 field projection. Comma-separated list of top-level fields. Case-insensitive.",
        "schema": {
          "type": "string"
        }
      },
      "ODataOrderBy": {
        "name": "$orderby",
        "in": "query",
        "required": false,
        "description": "OData v4 ordering expression. Restricted to supported fields and directions.",
        "schema": {
          "type": "string"
        }
      },
      "ODataFilter": {
        "name": "$filter",
        "in": "query",
        "required": false,
        "description": "OData v4 filter expression. Restricted to supported fields and operators.",
        "schema": {
          "type": "string"
        }
      }
    },
    "responses": {
      "Forbidden": {
        "description": "Tenant lacks `ai_chat` license (code: `feature_not_licensed`) or subject lacks permission (code: `insufficient_permissions`).",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      },
      "NotFound": {
        "description": "Resource not found or not accessible under current authorization constraints. Code: `chat_not_found` or `message_not_found`. AuthZ fail-closed: denied requests with a concrete resource ID return 404.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      }
    },
    "schemas": {
      "ErrorResponse": {
        "description": "Standard error envelope for JSON error responses and SSE terminal error events.",
        "oneOf": [
          { "$ref": "#/components/schemas/QuotaExceededError" },
          { "$ref": "#/components/schemas/GenericError" }
        ]
      },
      "GenericError": {
        "type": "object",
        "required": ["code", "message"],
        "description": "Error response for all non-quota error codes.",
        "properties": {
          "code": {
            "type": "string",
            "description": "Canonical error code.",
            "enum": [
              "feature_not_licensed",
              "insufficient_permissions",
              "chat_not_found",
              "message_not_found",
              "generation_in_progress",
              "request_id_conflict",
              "rate_limited",
              "web_search_disabled",
              "file_too_large",
              "unsupported_file_type",
              "too_many_images",
              "image_bytes_exceeded",
              "unsupported_media",
              "provider_error",
              "provider_timeout",
              "not_latest_turn",
              "invalid_turn_state",
              "invalid_reaction_target"
            ]
          },
          "message": {
            "type": "string",
            "description": "Human-readable error description."
          }
        }
      },
      "QuotaExceededError": {
        "type": "object",
        "required": ["code", "message", "quota_scope"],
        "description": "Error response for quota exhaustion. The quota_scope field is REQUIRED and distinguishes token quota exhaustion, upload quota exhaustion, and web search quota exhaustion.",
        "properties": {
          "code": {
            "type": "string",
            "enum": ["quota_exceeded"]
          },
          "message": {
            "type": "string",
            "description": "Human-readable error description."
          },
          "quota_scope": {
            "type": "string",
            "enum": ["tokens", "uploads", "web_search"],
            "description": "Distinguishes token quota exhaustion (tokens), upload quota exhaustion (uploads), and web search quota exhaustion (web_search). Clients MUST use this field, not message parsing, to determine quota scope."
          }
        }
      },
      "Chat": {
        "type": "object",
        "required": ["id", "model", "is_temporary", "created_at", "updated_at"],
        "description": "Chat metadata. Returned by create, list, and as part of chat detail.",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "model": {
            "type": "string",
            "description": "Model identifier from the deployment model catalog. Locked at creation for the chat lifetime."
          },
          "title": {
            "type": ["string", "null"],
            "maxLength": 255
          },
          "is_temporary": {
            "type": "boolean",
            "default": false,
            "description": "P2 feature. Schema column reserved; always false at P1."
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ChatDetail": {
        "description": "Chat metadata with message count. Returned by getChat. Does NOT embed messages; use `GET /v1/chats/{id}/messages` for paginated conversation history.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Chat"
          },
          {
            "type": "object",
            "required": ["message_count"],
            "properties": {
              "message_count": {
                "type": "integer",
                "format": "int64",
                "description": "Total number of non-deleted messages in this chat. UI uses this to decide whether to fetch history via GET /v1/chats/{id}/messages."
              }
            }
          }
        ]
      },
      "Message": {
        "type": "object",
        "required": ["id", "request_id", "role", "content", "attachment_ids", "created_at"],
        "description": "A single message in a chat (user, assistant, or system).",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "request_id": {
            "type": "string",
            "format": "uuid",
            "description": "Turn correlation key (doubles as idempotency key). Within a normal turn the user message and the assistant response share the same request_id. Client-generated, or server-generated UUID v4 when the client omits it. System/background messages (e.g. doc_summary) carry an independently server-generated UUID v4. Always present and non-null."
          },
          "role": {
            "type": "string",
            "enum": ["user", "assistant", "system"]
          },
          "content": {
            "type": "string"
          },
          "model": {
            "type": ["string", "null"],
            "description": "Effective model used. Present on assistant messages; null on user/system messages."
          },
          "input_tokens": {
            "type": ["integer", "null"],
            "description": "Actual input tokens. Present on assistant messages."
          },
          "output_tokens": {
            "type": ["integer", "null"],
            "description": "Actual output tokens. Present on assistant messages."
          },
          "attachment_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Always-present reference list of attachment UUIDs associated with this message. Empty array when no attachments. Details are fetched via GET /v1/chats/{id}/attachments/{attachment_id} if needed."
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "Attachment": {
        "type": "object",
        "required": ["attachment_id", "status", "kind", "filename", "content_type", "size_bytes", "created_at"],
        "description": "File attachment (document or image) on a chat.",
        "properties": {
          "attachment_id": {
            "type": "string",
            "format": "uuid"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "ready", "failed"],
            "description": "Processing status. Transitions: pending -> ready or pending -> failed."
          },
          "kind": {
            "type": "string",
            "enum": ["document", "image"],
            "description": "Derived from MIME type. image/png, image/jpeg, image/webp -> image; all other supported types -> document."
          },
          "filename": {
            "type": "string",
            "maxLength": 255
          },
          "content_type": {
            "type": "string",
            "description": "MIME type of the uploaded file."
          },
          "size_bytes": {
            "type": "integer",
            "format": "int64"
          },
          "doc_summary": {
            "type": ["string", "null"],
            "description": "Server-generated document summary (asynchronous background task). Null until processing completes; always null for images. Never provided by the client."
          },
          "img_thumbnail": {
            "oneOf": [
              { "$ref": "#/components/schemas/ImgThumbnail" },
              { "type": "null" }
            ],
            "description": "Server-generated preview thumbnail for image attachments. Null when kind is 'document', when kind is 'image' but thumbnail generation failed or was skipped, or when status is not 'ready'. Maximum decoded size (raw bytes before base64): 128 KiB by default (configurable via `thumbnail_max_bytes`). Stored internally in Mini Chat database only; never uploaded to provider. No provider identifiers. Never provided by the client."
          },
          "error_code": {
            "type": ["string", "null"],
            "description": "Stable internal error code when status is 'failed' (e.g. 'index_failed', 'provider_upload_failed'). Null when status is 'pending' or 'ready'. No provider identifiers in this field."
          },
          "summary_updated_at": {
            "type": ["string", "null"],
            "format": "date-time",
            "description": "Timestamp of summary generation."
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "TurnStatus": {
        "type": "object",
        "required": ["request_id", "state", "updated_at"],
        "description": "Authoritative server-side turn state for lifecycle resolution and disconnect recovery. Internal-to-API state mapping: running->running, completed->done, failed->error, cancelled->cancelled. Terminal states (done, error, cancelled) are immutable — once reached, the state never changes. Exactly one terminal outcome exists per (chat_id, request_id) pair. All terminal states indicate that quota settlement has been finalized atomically with the state transition. A state of 'done' guarantees that the full assistant message content is durably persisted and available for idempotent replay. Optional fields (error_code, assistant_message_id) provide actionable context so clients can resolve lifecycle uncertainty after disconnect without listing or scanning message history; retrieving the assistant message content may require one follow-up request. Billing outcome and provider internals are not exposed. chat_id is not included in the response body because it is already present in the URL path.",
        "properties": {
          "request_id": {
            "type": "string",
            "format": "uuid"
          },
          "state": {
            "type": "string",
            "enum": ["running", "done", "error", "cancelled"],
            "description": "Turn state. 'done', 'error', 'cancelled' are terminal and immutable. 'cancelled' indicates client disconnect or internal abort — no SSE error event was emitted. Use this endpoint to resolve state after disconnect."
          },
          "error_code": {
            "type": "string",
            "nullable": true,
            "description": "Terminal error code when state is 'error' (e.g. 'provider_error', 'orphan_timeout', 'context_length_exceeded'). Null for non-error terminal states and while running. Mapped from internal chat_turns.error_code. Provider identifiers and billing outcome are not exposed."
          },
          "assistant_message_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Persisted assistant message ID when state is 'done'. Null while running, on error, or on cancellation. Clients can use this to fetch the assistant message via `GET /v1/chats/{id}/messages?$filter=id eq '{assistant_message_id}'` without scanning full history."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "TurnDeleteResponse": {
        "type": "object",
        "required": ["request_id", "deleted"],
        "properties": {
          "request_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean",
            "const": true
          }
        }
      },
      "ReactionResponse": {
        "type": "object",
        "required": ["message_id", "reaction", "created_at"],
        "properties": {
          "message_id": {
            "type": "string",
            "format": "uuid"
          },
          "reaction": {
            "type": "string",
            "enum": ["like", "dislike"]
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ReactionDeleteResponse": {
        "type": "object",
        "required": ["message_id", "deleted"],
        "properties": {
          "message_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean",
            "const": true
          }
        }
      },
      "CreateChatRequest": {
        "type": "object",
        "description": "Request body for creating a new chat.",
        "properties": {
          "title": {
            "type": "string",
            "maxLength": 255,
            "description": "Optional chat title."
          },
          "model": {
            "type": "string",
            "description": "Model from the deployment model catalog. If omitted, the default model is resolved: the is_default premium model, then the first enabled premium model, then the first enabled standard model."
          }
        }
      },
      "SendMessageRequest": {
        "type": "object",
        "required": ["content"],
        "description": "Request body for sending a message. Opens an SSE stream on success.",
        "properties": {
          "content": {
            "type": "string",
            "description": "User message text."
          },
          "request_id": {
            "type": "string",
            "format": "uuid",
            "description": "Client-generated idempotency key. The server returns 409 Conflict if (a) any turn in this chat is already running (one running turn per chat), or (b) the same (chat_id, request_id) is in a non-replayable state (running, failed, or cancelled). If a completed turn exists for the same (chat_id, request_id), the server replays the durably stored response without any quota reserve or billing side effects."
          },
          "attachment_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Attachment IDs (images or documents) to include in this turn. Attachments must belong to this chat, must have status=ready, and are validated after effective model capability resolution."
          },
          "web_search": {
            "$ref": "#/components/schemas/WebSearchOption"
          }
        }
      },
      "EditTurnRequest": {
        "type": "object",
        "required": ["content"],
        "description": "Request body for editing the last user turn. Original attachment_ids are preserved automatically.",
        "properties": {
          "content": {
            "type": "string",
            "description": "Replacement user message text."
          }
        }
      },
      "SetReactionRequest": {
        "type": "object",
        "required": ["reaction"],
        "properties": {
          "reaction": {
            "type": "string",
            "enum": ["like", "dislike"]
          }
        }
      },
      "SseDeltaEvent": {
        "type": "object",
        "required": ["type", "content"],
        "description": "SSE `event: delta` payload. Streams incremental assistant text output.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Content type. P1: always \"text\". Reserved for future: \"markdown\", \"structured\".",
            "enum": ["text"]
          },
          "content": {
            "type": "string",
            "description": "Incremental text fragment."
          }
        }
      },
      "SseToolEvent": {
        "type": "object",
        "required": ["phase", "name"],
        "description": "SSE `event: tool` payload. Reports tool call activity (P1: file_search, web_search).",
        "properties": {
          "phase": {
            "type": "string",
            "enum": ["start", "progress", "done"]
          },
          "name": {
            "type": "string",
            "description": "Tool name. P1: \"file_search\", \"web_search\"."
          },
          "details": {
            "type": "object",
            "description": "Tool-specific non-sensitive details.",
            "properties": {
              "files_searched": {
                "type": "integer",
                "description": "Number of files searched. Present in phase=done."
              }
            },
            "additionalProperties": true
          }
        }
      },
      "SseCitationsEvent": {
        "type": "object",
        "required": ["items"],
        "description": "SSE `event: citations` payload. Delivers source references used in the answer. MAY include items from file_search (source=file) and/or web_search (source=web). Image inputs do not produce citations. Emitted at most once near stream completion before the terminal event (P1).",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CitationItem"
            }
          }
        }
      },
      "CitationItem": {
        "type": "object",
        "required": ["source", "title", "snippet"],
        "description": "A single citation reference.",
        "properties": {
          "source": {
            "type": "string",
            "enum": ["file", "web"],
            "description": "Citation source type. P1: \"file\" and \"web\" (when web search is enabled)."
          },
          "title": {
            "type": "string"
          },
          "url": {
            "type": "string",
            "format": "uri",
            "description": "URL for web sources. Present when source=\"web\"."
          },
          "attachment_id": {
            "type": "string",
            "format": "uuid",
            "description": "Internal attachment ID. The only file identifier exposed to clients."
          },
          "span": {
            "type": "object",
            "description": "Reserved for mapping citations to character positions in final assistant text.",
            "properties": {
              "start": {
                "type": "integer"
              },
              "end": {
                "type": "integer"
              }
            }
          },
          "snippet": {
            "type": "string",
            "description": "Relevant excerpt from the source."
          },
          "score": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Relevance score."
          }
        }
      },
      "SseDoneEvent": {
        "type": "object",
        "required": ["message_id", "usage", "effective_model", "selected_model", "quota_decision"],
        "description": "SSE `event: done` payload. Terminal event finalizing the stream with usage and model selection metadata.",
        "properties": {
          "message_id": {
            "type": "string",
            "format": "uuid",
            "description": "Persisted assistant message ID."
          },
          "usage": {
            "$ref": "#/components/schemas/SseUsage"
          },
          "effective_model": {
            "type": "string",
            "description": "Model actually used for this turn after quota and policy evaluation. Always present."
          },
          "selected_model": {
            "type": "string",
            "description": "Model chosen at chat creation (chats.model). Always present. Equals effective_model when no downgrade occurred."
          },
          "quota_decision": {
            "type": "string",
            "enum": ["allow", "downgrade"],
            "description": "Indicates whether the selected model was used as-is (allow) or a quota-driven downgrade occurred (downgrade). Always present."
          },
          "downgrade_from": {
            "type": "string",
            "description": "Always equals selected_model when present. The model from which the quota-driven downgrade occurred. Present only when quota_decision=\"downgrade\"."
          },
          "downgrade_reason": {
            "type": "string",
            "enum": ["premium_quota_exhausted", "kill_switch"],
            "description": "Why downgrade occurred. Present only when quota_decision=\"downgrade\"."
          }
        }
      },
      "SseUsage": {
        "type": "object",
        "required": ["input_tokens", "output_tokens", "model"],
        "description": "Token usage reported in the terminal done event.",
        "properties": {
          "input_tokens": {
            "type": "integer",
            "description": "Actual input tokens (includes image token costs if applicable)."
          },
          "output_tokens": {
            "type": "integer",
            "description": "Actual output tokens."
          },
          "model": {
            "type": "string",
            "description": "Effective model used for generation. May differ from the chat's locked model if a quota-driven downgrade occurred; see quota_decision on the done event."
          }
        }
      },
      "SseErrorEvent": {
        "description": "SSE `event: error` payload. Terminal event indicating a failure after the stream has started. Shares the same error envelope as JSON error responses: GenericError for all non-quota errors, QuotaExceededError (with required quota_scope) when code is quota_exceeded.",
        "oneOf": [
          { "$ref": "#/components/schemas/QuotaExceededError" },
          { "$ref": "#/components/schemas/GenericError" }
        ]
      },
      "WebSearchOption": {
        "type": "object",
        "description": "Controls web search for this turn. Defaults to disabled when omitted (backward compatible).",
        "properties": {
          "enabled": {
            "type": "boolean",
            "default": false,
            "description": "When true, the web_search tool is included in the provider request. The provider decides whether to invoke the tool. If the global disable_web_search kill switch is active, the request is rejected with web_search_disabled (400)."
          }
        }
      },
      "PageInfo": {
        "type": "object",
        "required": ["limit"],
        "description": "Cursor-based pagination metadata following the platform OData-style convention.",
        "properties": {
          "limit": {
            "type": "integer",
            "description": "The limit that was applied for this page."
          },
          "next_cursor": {
            "type": ["string", "null"],
            "description": "Opaque cursor for fetching the next page. Null when there are no more results."
          },
          "prev_cursor": {
            "type": ["string", "null"],
            "description": "Opaque cursor for fetching the previous page. Null on the first page."
          }
        }
      },
      "MessagesPage": {
        "type": "object",
        "required": ["items", "page_info"],
        "description": "Paginated list of messages following the platform Page + PageInfo convention.",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Message"
            }
          },
          "page_info": {
            "$ref": "#/components/schemas/PageInfo"
          }
        }
      },
      "ImgThumbnail": {
        "type": "object",
        "required": ["content_type", "width", "height", "data_base64"],
        "description": "Server-generated preview thumbnail for an image attachment. Produced during image upload processing using the Rust `image` crate. The thumbnail fits inside configured WxH dimensions (aspect ratio preserved, no cropping). Maximum decoded size (raw bytes before base64): 128 KiB by default (configurable via `thumbnail_max_bytes`). Stored internally in Mini Chat database only; never uploaded to provider Files API or external storage. No provider identifiers.",
        "properties": {
          "content_type": {
            "type": "string",
            "enum": ["image/webp"],
            "description": "MIME type of the thumbnail image. P1: always image/webp."
          },
          "width": {
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "description": "Thumbnail width in pixels."
          },
          "height": {
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "description": "Thumbnail height in pixels."
          },
          "data_base64": {
            "type": "string",
            "description": "Base64-encoded raw bytes of the thumbnail image. The enforced size limit (default 128 KiB, configurable via `thumbnail_max_bytes`) applies to the decoded binary bytes, not the base64 string."
          }
        }
      },
      "QuotaDecision": {
        "type": "string",
        "enum": ["allow", "downgrade"],
        "description": "Deprecated as standalone schema — fields are now inlined on SseDoneEvent. Retained for backward reference only."
      }
    }
  }
}
